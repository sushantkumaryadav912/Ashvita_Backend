'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var communicationCommon = require('@azure/communication-common');
var coreAuth = require('@azure/core-auth');
var coreClient = require('@azure/core-client');
var coreTracing = require('@azure/core-tracing');
var logger$1 = require('@azure/logger');

function _interopNamespaceDefault(e) {
    var n = Object.create(null);
    if (e) {
        Object.keys(e).forEach(function (k) {
            if (k !== 'default') {
                var d = Object.getOwnPropertyDescriptor(e, k);
                Object.defineProperty(n, k, d.get ? d : {
                    enumerable: true,
                    get: function () { return e[k]; }
                });
            }
        });
    }
    n.default = e;
    return Object.freeze(n);
}

var coreClient__namespace = /*#__PURE__*/_interopNamespaceDefault(coreClient);

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
const tracingClient = coreTracing.createTracingClient({
    namespace: "Microsoft.Communication",
    packageName: "@azure/communication-identity",
    packageVersion: "1.3.1"
});

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
const CommunicationIdentityCreateRequest = {
    type: {
        name: "Composite",
        className: "CommunicationIdentityCreateRequest",
        modelProperties: {
            createTokenWithScopes: {
                serializedName: "createTokenWithScopes",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            expiresInMinutes: {
                defaultValue: 1440,
                constraints: {
                    InclusiveMaximum: 1440,
                    InclusiveMinimum: 60
                },
                serializedName: "expiresInMinutes",
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const CommunicationIdentityAccessTokenResult = {
    type: {
        name: "Composite",
        className: "CommunicationIdentityAccessTokenResult",
        modelProperties: {
            identity: {
                serializedName: "identity",
                type: {
                    name: "Composite",
                    className: "CommunicationIdentity"
                }
            },
            accessToken: {
                serializedName: "accessToken",
                type: {
                    name: "Composite",
                    className: "CommunicationIdentityAccessToken"
                }
            }
        }
    }
};
const CommunicationIdentity = {
    type: {
        name: "Composite",
        className: "CommunicationIdentity",
        modelProperties: {
            id: {
                serializedName: "id",
                required: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const CommunicationIdentityAccessToken = {
    type: {
        name: "Composite",
        className: "CommunicationIdentityAccessToken",
        modelProperties: {
            token: {
                serializedName: "token",
                required: true,
                type: {
                    name: "String"
                }
            },
            expiresOn: {
                serializedName: "expiresOn",
                required: true,
                type: {
                    name: "DateTime"
                }
            }
        }
    }
};
const CommunicationErrorResponse = {
    type: {
        name: "Composite",
        className: "CommunicationErrorResponse",
        modelProperties: {
            error: {
                serializedName: "error",
                type: {
                    name: "Composite",
                    className: "CommunicationError"
                }
            }
        }
    }
};
const CommunicationError = {
    type: {
        name: "Composite",
        className: "CommunicationError",
        modelProperties: {
            code: {
                serializedName: "code",
                required: true,
                type: {
                    name: "String"
                }
            },
            message: {
                serializedName: "message",
                required: true,
                type: {
                    name: "String"
                }
            },
            target: {
                serializedName: "target",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            details: {
                serializedName: "details",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "CommunicationError"
                        }
                    }
                }
            },
            innerError: {
                serializedName: "innererror",
                type: {
                    name: "Composite",
                    className: "CommunicationError"
                }
            }
        }
    }
};
const TeamsUserExchangeTokenRequest = {
    type: {
        name: "Composite",
        className: "TeamsUserExchangeTokenRequest",
        modelProperties: {
            token: {
                serializedName: "token",
                required: true,
                type: {
                    name: "String"
                }
            },
            appId: {
                serializedName: "appId",
                required: true,
                type: {
                    name: "String"
                }
            },
            userId: {
                serializedName: "userId",
                required: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const CommunicationIdentityAccessTokenRequest = {
    type: {
        name: "Composite",
        className: "CommunicationIdentityAccessTokenRequest",
        modelProperties: {
            scopes: {
                serializedName: "scopes",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            expiresInMinutes: {
                defaultValue: 1440,
                constraints: {
                    InclusiveMaximum: 1440,
                    InclusiveMinimum: 60
                },
                serializedName: "expiresInMinutes",
                type: {
                    name: "Number"
                }
            }
        }
    }
};

var Mappers = /*#__PURE__*/Object.freeze({
    __proto__: null,
    CommunicationError: CommunicationError,
    CommunicationErrorResponse: CommunicationErrorResponse,
    CommunicationIdentity: CommunicationIdentity,
    CommunicationIdentityAccessToken: CommunicationIdentityAccessToken,
    CommunicationIdentityAccessTokenRequest: CommunicationIdentityAccessTokenRequest,
    CommunicationIdentityAccessTokenResult: CommunicationIdentityAccessTokenResult,
    CommunicationIdentityCreateRequest: CommunicationIdentityCreateRequest,
    TeamsUserExchangeTokenRequest: TeamsUserExchangeTokenRequest
});

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
const contentType = {
    parameterPath: ["options", "contentType"],
    mapper: {
        defaultValue: "application/json",
        isConstant: true,
        serializedName: "Content-Type",
        type: {
            name: "String"
        }
    }
};
const accept = {
    parameterPath: "accept",
    mapper: {
        defaultValue: "application/json",
        isConstant: true,
        serializedName: "Accept",
        type: {
            name: "String"
        }
    }
};
const endpoint = {
    parameterPath: "endpoint",
    mapper: {
        serializedName: "endpoint",
        required: true,
        type: {
            name: "String"
        }
    },
    skipEncoding: true
};
const apiVersion = {
    parameterPath: "apiVersion",
    mapper: {
        defaultValue: "2023-10-01",
        isConstant: true,
        serializedName: "api-version",
        type: {
            name: "String"
        }
    }
};
const id = {
    parameterPath: "id",
    mapper: {
        serializedName: "id",
        required: true,
        type: {
            name: "String"
        }
    }
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/** Class containing CommunicationIdentityOperations operations. */
class CommunicationIdentityOperationsImpl {
    /**
     * Initialize a new instance of the class CommunicationIdentityOperations class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Create a new identity, and optionally, an access token.
     * @param options The options parameters.
     */
    async create(options) {
        return tracingClient.withSpan("IdentityRestClient.create", options !== null && options !== void 0 ? options : {}, async (options) => {
            return this.client.sendOperationRequest({ options }, createOperationSpec);
        });
    }
    /**
     * Delete the identity, revoke all tokens for the identity and delete all associated data.
     * @param id Identifier of the identity to be deleted.
     * @param options The options parameters.
     */
    async delete(id, options) {
        return tracingClient.withSpan("IdentityRestClient.delete", options !== null && options !== void 0 ? options : {}, async (options) => {
            return this.client.sendOperationRequest({ id, options }, deleteOperationSpec);
        });
    }
    /**
     * Revoke all access tokens for the specific identity.
     * @param id Identifier of the identity.
     * @param options The options parameters.
     */
    async revokeAccessTokens(id, options) {
        return tracingClient.withSpan("IdentityRestClient.revokeAccessTokens", options !== null && options !== void 0 ? options : {}, async (options) => {
            return this.client.sendOperationRequest({ id, options }, revokeAccessTokensOperationSpec);
        });
    }
    /**
     * Exchange an Azure Active Directory (Azure AD) access token of a Teams user for a new Communication
     * Identity access token with a matching expiration time.
     * @param token Azure AD access token of a Teams User to acquire a new Communication Identity access
     *              token.
     * @param appId Client ID of an Azure AD application to be verified against the appid claim in the
     *              Azure AD access token.
     * @param userId Object ID of an Azure AD user (Teams User) to be verified against the oid claim in the
     *               Azure AD access token.
     * @param options The options parameters.
     */
    async exchangeTeamsUserAccessToken(token, appId, userId, options) {
        return tracingClient.withSpan("IdentityRestClient.exchangeTeamsUserAccessToken", options !== null && options !== void 0 ? options : {}, async (options) => {
            return this.client.sendOperationRequest({ token, appId, userId, options }, exchangeTeamsUserAccessTokenOperationSpec);
        });
    }
    /**
     * Issue a new token for an identity.
     * @param id Identifier of the identity to issue token for.
     * @param scopes List of scopes attached to the token.
     * @param options The options parameters.
     */
    async issueAccessToken(id, scopes, options) {
        return tracingClient.withSpan("IdentityRestClient.issueAccessToken", options !== null && options !== void 0 ? options : {}, async (options) => {
            return this.client.sendOperationRequest({ id, scopes, options }, issueAccessTokenOperationSpec);
        });
    }
}
// Operation Specifications
const serializer = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const createOperationSpec = {
    path: "/identities",
    httpMethod: "POST",
    responses: {
        201: {
            bodyMapper: CommunicationIdentityAccessTokenResult
        },
        default: {
            bodyMapper: CommunicationErrorResponse
        }
    },
    requestBody: {
        parameterPath: {
            createTokenWithScopes: ["options", "createTokenWithScopes"],
            expiresInMinutes: ["options", "expiresInMinutes"]
        },
        mapper: CommunicationIdentityCreateRequest
    },
    queryParameters: [apiVersion],
    urlParameters: [endpoint],
    headerParameters: [contentType, accept],
    mediaType: "json",
    serializer
};
const deleteOperationSpec = {
    path: "/identities/{id}",
    httpMethod: "DELETE",
    responses: {
        204: {},
        default: {
            bodyMapper: CommunicationErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [endpoint, id],
    headerParameters: [accept],
    serializer
};
const revokeAccessTokensOperationSpec = {
    path: "/identities/{id}/:revokeAccessTokens",
    httpMethod: "POST",
    responses: {
        204: {},
        default: {
            bodyMapper: CommunicationErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [endpoint, id],
    headerParameters: [accept],
    serializer
};
const exchangeTeamsUserAccessTokenOperationSpec = {
    path: "/teamsUser/:exchangeAccessToken",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: CommunicationIdentityAccessToken
        },
        default: {
            bodyMapper: CommunicationErrorResponse
        }
    },
    requestBody: {
        parameterPath: { token: ["token"], appId: ["appId"], userId: ["userId"] },
        mapper: Object.assign(Object.assign({}, TeamsUserExchangeTokenRequest), { required: true })
    },
    queryParameters: [apiVersion],
    urlParameters: [endpoint],
    headerParameters: [contentType, accept],
    mediaType: "json",
    serializer
};
const issueAccessTokenOperationSpec = {
    path: "/identities/{id}/:issueAccessToken",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: CommunicationIdentityAccessToken
        },
        default: {
            bodyMapper: CommunicationErrorResponse
        }
    },
    requestBody: {
        parameterPath: {
            scopes: ["scopes"],
            expiresInMinutes: ["options", "expiresInMinutes"]
        },
        mapper: Object.assign(Object.assign({}, CommunicationIdentityAccessTokenRequest), { required: true })
    },
    queryParameters: [apiVersion],
    urlParameters: [endpoint, id],
    headerParameters: [contentType, accept],
    mediaType: "json",
    serializer
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
class IdentityRestClient extends coreClient__namespace.ServiceClient {
    /**
     * Initializes a new instance of the IdentityRestClient class.
     * @param endpoint The communication resource, for example https://my-resource.communication.azure.com
     * @param options The parameter options
     */
    constructor(endpoint, options) {
        var _a, _b;
        if (endpoint === undefined) {
            throw new Error("'endpoint' cannot be null");
        }
        // Initializing default values for options
        if (!options) {
            options = {};
        }
        const defaults = {
            requestContentType: "application/json; charset=utf-8"
        };
        const packageDetails = `azsdk-js-communication-identity/1.3.1`;
        const userAgentPrefix = options.userAgentOptions && options.userAgentOptions.userAgentPrefix
            ? `${options.userAgentOptions.userAgentPrefix} ${packageDetails}`
            : `${packageDetails}`;
        const optionsWithDefaults = Object.assign(Object.assign(Object.assign({}, defaults), options), { userAgentOptions: {
                userAgentPrefix
            }, endpoint: (_b = (_a = options.endpoint) !== null && _a !== void 0 ? _a : options.baseUri) !== null && _b !== void 0 ? _b : "{endpoint}" });
        super(optionsWithDefaults);
        // Parameter assignments
        this.endpoint = endpoint;
        // Assigning values to Constant parameters
        this.apiVersion = options.apiVersion || "2023-10-01";
        this.communicationIdentityOperations = new CommunicationIdentityOperationsImpl(this);
        this.addCustomApiVersionPolicy(options.apiVersion);
    }
    /** A function that adds a policy that sets the api-version (or equivalent) to reflect the library version. */
    addCustomApiVersionPolicy(apiVersion) {
        if (!apiVersion) {
            return;
        }
        const apiVersionPolicy = {
            name: "CustomApiVersionPolicy",
            async sendRequest(request, next) {
                const param = request.url.split("?");
                if (param.length > 1) {
                    const newParams = param[1].split("&").map((item) => {
                        if (item.indexOf("api-version") > -1) {
                            return "api-version=" + apiVersion;
                        }
                        else {
                            return item;
                        }
                    });
                    request.url = param[0] + "?" + newParams.join("&");
                }
                return next(request);
            }
        };
        this.pipeline.addPolicy(apiVersionPolicy);
    }
}

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/**
 * The \@azure/logger configuration for this package.
 */
const logger = logger$1.createClientLogger("communication-identity");

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
const isCommunicationIdentityClientOptions = (options) => options && !coreAuth.isTokenCredential(options) && !communicationCommon.isKeyCredential(options);
/**
 * Client class for interacting with Azure Communication Services User Token Management.
 */
class CommunicationIdentityClient {
    constructor(connectionStringOrEndpoint, credentialOrOptions, maybeOptions = {}) {
        const { url, credential } = communicationCommon.parseClientArguments(connectionStringOrEndpoint, credentialOrOptions);
        const options = isCommunicationIdentityClientOptions(credentialOrOptions)
            ? credentialOrOptions
            : maybeOptions;
        const internalPipelineOptions = Object.assign(Object.assign({}, options), {
            loggingOptions: {
                logger: logger.info,
            },
        });
        this.client = new IdentityRestClient(url, Object.assign({ endpoint: url }, internalPipelineOptions));
        const authPolicy = communicationCommon.createCommunicationAuthPolicy(credential);
        this.client.pipeline.addPolicy(authPolicy);
    }
    /**
     * Creates a scoped user token.
     *
     * @param user - The user whose tokens are being issued.
     * @param scopes - Scopes to include in the token.
     * @param options - Additional options for the request.
     */
    getToken(user, scopes, options = {}) {
        return tracingClient.withSpan("CommunicationIdentity-issueToken", options, (updatedOptions) => {
            return this.client.communicationIdentityOperations.issueAccessToken(user.communicationUserId, scopes, Object.assign({ expiresInMinutes: options.tokenExpiresInMinutes }, updatedOptions));
        });
    }
    /**
     * Revokes all data and tokens created for a user.
     *
     * @param user - The user whose tokens are being revoked.
     * @param options - Additional options for the request.
     */
    revokeTokens(user, options = {}) {
        return tracingClient.withSpan("CommunicationIdentity-revokeTokens", options, async (updatedOptions) => {
            await this.client.communicationIdentityOperations.revokeAccessTokens(user.communicationUserId, updatedOptions);
        });
    }
    /**
     * Creates a single user.
     *
     * @param options - Additional options for the request.
     */
    createUser(options = {}) {
        return tracingClient.withSpan("CommunicationIdentity-createUser", options, async (updatedOptions) => {
            const result = await this.client.communicationIdentityOperations.create(Object.assign({ expiresInMinutes: undefined }, updatedOptions));
            return {
                communicationUserId: result.identity.id,
            };
        });
    }
    /**
     * Creates a single user and a token simultaneously.
     *
     * @param scopes - Scopes to include in the token.
     * @param options - Additional options for the request.
     */
    createUserAndToken(scopes, options = {}) {
        return tracingClient.withSpan("CommunicationIdentity-createUserAndToken", options, async (updatedOptions) => {
            const { identity, accessToken } = await this.client.communicationIdentityOperations.create(Object.assign({ createTokenWithScopes: scopes, expiresInMinutes: options.tokenExpiresInMinutes }, updatedOptions));
            return Object.assign(Object.assign({}, accessToken), { user: { communicationUserId: identity.id } });
        });
    }
    /**
     * Triggers revocation event for user and deletes all its data.
     *
     * @param user - The user being deleted.
     * @param options - Additional options for the request.
     */
    deleteUser(user, options = {}) {
        return tracingClient.withSpan("CommunicationIdentity-deleteUser", options, async (updatedOptions) => {
            await this.client.communicationIdentityOperations.delete(user.communicationUserId, updatedOptions);
        });
    }
    /**
     * Exchanges an Azure AD access token of a Teams user for a new Communication Identity access token with a matching expiration time.
     *
     * @param options - Options used to exchange an Azure AD access token of a Teams user for a new Communication Identity access token.
     */
    getTokenForTeamsUser(options) {
        return tracingClient.withSpan("CommunicationIdentity-getTokenForTeamsUser", options, (updatedOptions) => {
            const { teamsUserAadToken, clientId, userObjectId } = updatedOptions;
            return this.client.communicationIdentityOperations.exchangeTeamsUserAccessToken(teamsUserAadToken, clientId, userObjectId, updatedOptions);
        });
    }
}

exports.CommunicationIdentityClient = CommunicationIdentityClient;
//# sourceMappingURL=index.js.map
